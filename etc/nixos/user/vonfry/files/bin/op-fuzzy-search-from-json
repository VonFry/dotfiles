#!/usr/bin/env nix-shell
#!nix-shell -i runhaskell -p 'ghc.withPackages (p: with p; [ aeson process ])'

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

import System.Process (readProcess)
import Data.Aeson 
import Data.Aeson.Types (parse, Parser) 
import System.Environment (getArgs)
import Data.String (fromString)
import Data.List (intercalate)
import Text.Printf (printf)
import Data.List
import Data.Foldable
import Control.Monad
import Data.Maybe

main :: IO ()
main = do
    itemsRaw <- readProcess "op" [ "list", "items" ] ""
    let items = fromJust $ decode $ fromString itemsRaw
    args <- getArgs
    let searched = search items args
    if length searched == 1
       then printPasswd $ head searched
       else askSearch searched

data Searched = Searched { uuid     :: String
                         , overview :: Overview
                         , urls     :: [String]
                         }

data Overview = Overview { title :: String
                         , ainfo :: String
                         , tags  :: [String]
                         , url   :: String
                         }

data Passwd = Passwd { username :: String
                     , password :: String
                     }

instance FromJSON Searched where
    parseJSON = withObject "Searched" $ \v -> Searched
        <$> v .: "uuid"
        <*> v .: "overview"
        <*> do urls <- v .:? "URLs" .!= ([] :: [Object])
               return $ fmap (fromResult . fromJSON) $ concat $ toList <$> urls
      where
        fromResult (Success s) = s

instance FromJSON Overview where
    parseJSON = withObject "Overview" $ \v -> Overview
        <$> v .: "title"
        <*> do infoM <- v .:? "ainfo"
               return $ maybe "" id infoM
        <*> do tags <- v .:? "tags" .!= ([] :: [Object])
               return $ fmap (fromResult . fromJSON) $ concat $ fmap toList tags
        <*> v .:? "url" .!= ""
      where
        fromResult (Success s) = s
               
instance FromJSON Passwd where
    parseJSON = withObject "Passwd" $ \v -> Passwd
        <$> getDetails v "username"
        <*> getDetails v "password"
      where
        getDetails v k = do
            details <- v .: "details"
            fields <- details .: "fields"
            maybe (return "") (.:"value") $ find (findField k) (fields :: [Object])
        findField :: String -> Object -> Bool
        findField k f = (fromResult $ parse (.:"designation") f) == k
        fromResult (Success s) = s

search :: [Searched] -> [String] -> [Searched]
search s args = filter f s
  where
    f s = and $ fmap ($s) [ matchTitle, matchTags, matchUrl, matchUrls ]
    match s = and $ flip isInfixOf s <$> args
    matchTitle s =
        let o = overview s 
            t = title o
        in match t
    matchTags s =
        let o = overview s 
            t = intercalate " " $ tags o
        in match t
    matchUrl s =
        let o = overview s 
            u = url o
        in match u
    matchUrls s =
        let u = intercalate "\n" $ urls s 
        in match u

askSearch :: [Searched] -> IO ()
askSearch searched = do
    printSearch searched
    idxRaw <-  getLine
    let idx = read idxRaw
    printPasswd $ searched !! idx

printSearch :: [Searched] -> IO ()
printSearch s = mapM_ print1 [0..(length s)]
  where
    print1 :: Int -> IO ()
    print1 idx = do
        printf "index: %d" idx
        let obj = s !! idx
        let o = overview obj
        printf "UUID:  %s\n" $ uuid  obj
        printf "Title: %s\n" $ title o
        printf "Tags:  %s\n" $ intercalate ", " $ tags o 
        printf "Ainfo: %s\n" $ ainfo o
        printf "url:   %s\n" $ url   o
        printf "URLs:\n"
        mapM_ (printf "       %s\n") $ urls obj
        printf "\n"

printPasswd :: Searched -> IO ()
printPasswd s = do
    passwdRaw <- readProcess "op" [ "get", "item", uuid s ] ""
    let passwd = fromJust $ decode $ fromString passwdRaw
    printf "username: %s" $ username passwd
    printf "password: %s" $ password passwd