#!/usr/bin/env runhaskell

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

import System.Process (readProcess)
import Data.Aeson 
import Data.Aeson.Types (parseMaybe) 
import System.Environment (getArgs)
import Data.String (fromString)
import Data.List (intercalate)
import Text.Printf (printf)
import Data.List
import Data.Foldable
import Control.Monad
import Data.Maybe
import Data.Text.Lazy (pack)
import Data.Text.Lazy.Encoding (encodeUtf8)

main :: IO ()
main = do
    itemsRaw <- readProcess "op" [ "list", "items" ] ""
    let items = fromJust $ decode $ encodeUtf8 $ pack itemsRaw
    args <- getArgs
    let searched = search items args
    idx <- askSearch $ searched
    printPasswd $ searched !! idx

data Searched = Searched { uuid     :: String
                         , overview :: Overview
                         }

data Overview = Overview { title :: String
                         , ainfo :: String
                         , tags  :: [String]
                         , url   :: String
                         , urls  :: [String]
                         }

data Passwd = Passwd { username :: String
                     , password :: String
                     }

instance FromJSON Searched where
    parseJSON = withObject "Searched" $ \v -> Searched
        <$> v .: "uuid"
        <*> v .: "overview"

instance FromJSON Overview where
    parseJSON = withObject "Overview" $ \v -> Overview
        <$> v .: "title"
        <*> do infoM <- v .:? "ainfo"
               return $ maybe "" id infoM
        <*> v .:? "tags" .!= ([] :: [String])
        <*> v .:? "url" .!= ""
        <*> do urls <- v .:? "URLs" .!= ([] :: [Object]) 
               return $ fmap (fromJust . parseMaybe ((.!= "") . (.:? "u"))) urls
               
instance FromJSON Passwd where
    parseJSON = withObject "Passwd" $ \v -> Passwd
        <$> getDetails v "username"
        <*> getDetails v "password"
      where
        getDetails v k = do
            details <- v .: "details"
            fields <- details .: "fields"
            maybe (return "") (.:"value") $ find (findField k) (fields :: [Object])
        findField :: String -> Object -> Bool
        findField k f = (fromJust $ parseMaybe (.:"designation") f) == k

search :: [Searched] -> [String] -> [Searched]
search s args = filter f s
  where
    f s = or $ fmap ($ s) [ matchTitle, matchTags, matchUrl, matchUrls ]
    match s = or $ flip isInfixOf s <$> args
    matchTitle s =
        let o = overview s 
            t = title o
        in match t
    matchTags s =
        let o = overview s 
            t = intercalate " " $ tags o
        in match t
    matchUrl s =
        let o = overview s 
            u = url o
        in match u
    matchUrls s =
        let o = overview s
            u = intercalate "\n" $ urls o 
        in match u

askSearch :: [Searched] -> IO Int
askSearch searched = do
    printSearch searched
    if length searched == 1
       then return 0 
       else do putStr "index: "
               idx <- getLine
               return $ read idx

printSearch :: [Searched] -> IO ()
printSearch [] = putStrLn "No Result."
printSearch s = mapM_ print1 [0..(length s - 1)]
  where
    print1 :: Int -> IO ()
    print1 idx = do
        printf "index: %d\n" idx
        let obj = s !! idx
        let o = overview obj
        printf "UUID:  %s\n" $ uuid  obj
        printf "Title: %s\n" $ title o
        printf "Tags:  %s\n" $ intercalate ", " $ tags o 
        printf "Ainfo: %s\n" $ ainfo o
        printf "Url:   %s\n" $ url   o
        printf "URLs:\n"
        mapM_ (printf "       %s\n") $ urls o
        printf "\n"

printPasswd :: Searched -> IO ()
printPasswd s = do
    passwdRaw <- readProcess "op" [ "get", "item", uuid s ] ""
    let passwd = fromJust $ decode $ encodeUtf8 $ pack passwdRaw
    printf "username: %s\n" $ username passwd
    printf "password: %s\n" $ password passwd